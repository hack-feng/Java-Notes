### 面试官👴：小伙子，了解Spring的事务吗？

解读🔔：这个必须了解，不了解直接挂~😂😂😂，但面试官肯定不是想听你了解两个字，他是想让你简单的介绍下。

笑小枫🍁：了解，事务在逻辑上是一组操作，要么执行，要不都不执行。主要是针对数据库而言的，比如说 MySQL。为了保证事务是正确可靠的，在数据库进行写入或者更新操作时，就必须得表现出 ACID 的 4 个重要特性。

### 面试官👴：你刚刚提到了ACID，那你简单的介绍一下这4个特性

解读🔔：在介绍事务的时候，本可以把特性介绍了，但是偏偏不，故意一提，但不展开描述。为的就是让面试官进入到我们的节奏😏😏😏虽然是你面试我，但我要牵着你的鼻子走，面试就是一场心理战，这才刚刚开始~

笑小枫🍁：ACID分别是**原子性（Atomicity）**、**一致性（Consistency）**、**事务隔离（Isolation）**、**持久性（Durability）**。

其中：**原子性（Atomicity）**是一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

**一致性（Consistency）**是在事务开始之前和事务结束以后，数据库的完整性没有被破坏。

**事务隔离（Isolation）**是数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

**持久性（Durability）**是事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

正是因为这4个特性，我们在项目中会频繁的使用事务。

### 面试官👴：你刚刚说，在项目中频繁使用事务，都是什么场景下使用的呢？

解读🔔：又跟着节奏来了，这个比较简单

笑小枫🍁：事务使用场景分为两种**读写事务**和**只读事务**。

我们常用的场景中，多表操作的时候会使用**读写事务**，例如A转账给B的时候，需要A扣款成功，

B到账成功，就要用到事务的原子性、一致性和持久性；在多表查询的时候，我们会用到**只读事务**，例如A有1000元，B有2000元，这个时候总金额应该为3000元。
~~~sql
select amount from user where id = 'A';
select amount from user where id = 'B';
~~~
如果查询完A后取到了1000元，然后A转账给B 1000元，如果没有事务，查询到B为3000元，这个时候总额就是4000元了，所以可以使用只读事务，保证数据的隔离性和一致性。

### 面试官👴：你能说说具体是怎么使用的吗？

笑小枫🍁：事务使用一般有管理机制，一种是**编程式事务**，就是在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强，我们很少使用；另外一种是**声明式事务**，使用`@Transactional`注解，它是基于AOP面向切面的，将具体业务与事务处理部分解耦，代码侵入性很低，我们项目中使用这种方式比较多。

### 面试官👴：你刚刚提到了Transactional，你知道它有几种作用域吗？

笑小枫🍁：可以作用在**类**、**方法**、**接口**上；

当把注解放在类上时，表示所有该类的public方法都配置相同的事务属性信息。

当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。

不推荐作用在接口上，因为这只有在使用基于接口的代理时它才会生效，一旦配置了Spring AOP使用CGLib动态代理，将会导致@Transactional注解失效。

### 面试官👴：除了作用在类上时，Spring AOP使用CGLib动态代理，@Transactional会失效外，你还知道其它的场景会导致事务失效吗？

解读🔔：这还不简单，这不就是我给你挖的坑嘛😏😏😏简单的罗列几种情况吧

笑小枫🍁：

**1、@Transactional 应用在非 public 修饰的方法上**

> 如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效。
> 原因是：TransactionInterceptor （事务拦截器）使用AOP，在目标方法执行前后进行拦截，会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。（spring要求被代理方法必须是public的。）

**2、@Transactional 注解属性 propagation 设置错误**

> 这种是因为propagation的参数设置错误，根据需求选择合适的@Transactional的propagation属性的值

**3、@Transactional 注解属性 rollbackFor 设置错误**

> rollbackFor默认是error和RuntimeException会触发回滚，其他异常或自定义异常不会回滚，需要回滚则需要指定或者直接指定@Transactional(rollbackFor=Exception.class)

**4、同一个类中方法调用，导致@Transactional失效**

> 这个和redis缓存失效场景之一一样，如果在一个类中，B方法加了事务，A方法没加事务调用B方法，另外一个类调用A方法，则B方法的事务失效。这种情况可以加一层Mamager层对Service层通用能力的下沉。

**5、异常被捕获，导致@Transactional失效**

> 当我们是用catch把异常捕获了，那么该方法就不会抛出异常了，那么出现该异常就不会回滚了

**6、数据库引擎不支持事务**

> 这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的innodb引擎。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。

**7、没有被 Spring 管理**

如下面例子所示：

```java
@Service
public class OrderService {
    @Transactional
    public void updateOrder(Order order) {
        // update order
    }
}
```

如果此时把 @Service 注解注释掉，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。

**8、方法被定义为final**

> 方法被定义成了final的，这样会导致spring aop生成的代理对象不能复写该方法，而让事务失效。