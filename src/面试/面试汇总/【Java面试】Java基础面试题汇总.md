### 写在前面

> 或许你只是想白嫖内容，或许你也会忽略这段文字，但我还是想弱弱的说
> 题目虽不全是原创，但整理也耗费了大量精力，希望阅读之前可以给博主点赞收藏，谢谢大家啦
> 我呢，笑小枫，一个努力的普通人，也希望可以花1秒钟记住我一下
> 也希望可以关注我的公众号，或者去小程序免费撸题
> 就说到这里了，希望现在努力的我们，拥有未来最好的自己，开始撸题吧~


### 1、 面向对象的特征有哪些方面？

* 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

* 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类)；得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段(如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分)。

* 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口(可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情)。

* 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的(就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力)。方法重载	(overload)实现的是编译时的多态性(也称为前绑定)，而方法重写(override)实现的是运行时的多态性(也称为后绑定)。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：

  1. 方法重写(子类继承父类并重写父类中已有的或抽象的方法)；

  2. 对象造型(用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为)。

### 2、访问修饰符public,private,protected,以及不写(默认)时的区别？

| 修饰符 | 当前类 | 同包 | 子类 | 其他包 |
| ------ | ------ | ---- | ---- | ------ |
| public | √      | √    | √    | √      |
| protected | √    | √    | √    | ×    |
| default   | √    | √    | ×    | ×    |
| private   | √    | ×    | ×    | ×    |

类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开(public)，对于不是同一个包中的其他类相当于私有(private)。受保护(protected)对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员(包括内部类)的修饰符可以是以上四种。

### 3、String是最基本的数据类型吗？

不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型(primitivetype)，剩下的都是引用类型(referencetype)，Java5以后引入的枚举类型也算是一种比较特殊的引用类型。

### 4、float f = 3.4;是否正确？

不正确。3.4是双精度数，将双精度型(double)赋值给浮点型(float)属于下转型(down-casting，也称为窄化)会造成精度损失，因此需要强制类型转换floatf=(float)3.4;或者写成floatf=3.4F;。

### 5、short s1 = 1;s1 = s1+1;有错吗?short s1=1; s1+=1;有错吗？

对于short s1=1;s1=s1+1;由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型。而short s1=1;s1+=1;可以正确编译，因为s1+=1;相当于s1=(short)(s1+1);其中有隐含的强制类型转换。

### 6、Java有没有goto？

goto是Java中的保留字，在目前版本的Java中没有使用。(根据JamesGosling	(Java之父)编写的《TheJavaProgrammingLanguage》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字)

### 7、int和Integer有什么区别？

Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapperclass)，int的包装类就是Integer，从Java5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。

Java为每个原始类型提供了包装类型：

原始类型：boolean，char，byte，short，int，long，float，double

包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，

如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象

提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。

### 8、&和&&的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username!=null&&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符(|)和短路或运算符(||)的差别也是如此。

补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。

### 9、解释内存中的栈(stack)、堆(heap)和方法区(methodarea)的用法。

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor(又可分为FromSurvivor和ToSurvivor)、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量(literal)如直接书写的### ”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

~~~java
String str = new String("hello");
~~~

上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量是放在方法区的。

补充1：较新版本的Java(从Java6的某个更新开始)中，由于JIT编译器的发展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。

补充2：运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。

### 10、Math.round(11.5)等于多少？Math.round(-11.5)等于多少？

Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。

### 11、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？

在Java5以前，switch(expr)中，expr只能是byte、short、char、int。从Java5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java7开始，expr还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。

### 12、用最有效率的方法计算2乘以8？

2<<3(左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方)。

### 13、数组有没有length()方法？String有没有length()方法？

数组没有length()方法，有length的属性。String有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。

### 14、在Java中，如何跳出当前的多重嵌套循环？

在最外层循环前加一个标记如A，然后用breakA;可以跳出多重循环。(Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好)

### 15、构造器(constructor)是否可被重写(override)？
构造器不能被继承，因此不能被重写，但可以被重载。

两个对象值相同(x.equals(y) == true)，但却可有不同的hashcode，这句话对不对？不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码(hashcode)应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同(equals方法返回true)，那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降(对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降)。

### 16、是否可以继承String类？

String类是final类，不可以被继承。

补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系(Has-A)和依赖关系(Use-A)而不是继承关系(Is-A)。

### 17、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？

是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。

说明：Java中没有传引用实在是非常的不方便，这一点在Java8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类(将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法)，这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。

### 18、String和StringBuilder、StringBuffer的区别？

Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。


### 19、重载(Overload)和重写(Override)的区别？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性；

重载发生在一个类中，同名的方法如果有不同的参数列表(参数类型不同、参数个数不同或者二者都不同)则视为重载；

重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常(里氏代换原则)。重载对返回类型没有特殊的要求。


### 20、描述一下JVM加载class文件的原理机制？

JVM中类的装载是由类加载器(ClassLoader)和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。

由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：

1. 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；

2. 如果类中存在初始化语句，就依次执行这些初始化语句。

类的加载是由类加载器完成的，类加载器包括：根加载器(BootStrap)、扩展加载器(Extension)、系统加载器(System)和用户自定义类加载器(java.lang.ClassLoader的子类)。从Java2(JDK1.2)开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载


器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：

Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库(rt.jar)；

Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap System

Bootstrap System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

### 21、抽象类(abstractclass)和接口(interface)有什么异同？

抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

### 22、静态嵌套类(Static Nested Class)和内部类(Inner Class)的不同？

StaticNestedClass是被声明为静态(static)的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化

### 23、Java中会存在内存泄漏吗？

理论上Java因为有垃圾回收机制(GC)不会存在内存泄露问题(这也是Java被广泛使用于服务器端编程的一个重要原因)；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session(一级缓存)中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭(close)或清空(flush)一级缓存就可能导致内存泄露。

### 24、阐述静态变量和实例变量的区别？

静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。
### 25、是否可以从一个静态(static)方法内部发出对非静态

(non-static)方法的调用？不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。

### 26、如何实现对象克隆？

有两种方式：

1. 实现Cloneable接口并重写Object类中的clone()方法；

2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆

### 27、GC是什么？为什么要有GC？

GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc()或Runtime.getRuntime().gc()，但JVM可以屏蔽掉显示的垃圾回收调用。

垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。

### 28、String s = new String(“xyz”);创建了几个字符串对象？
两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。

### 29、接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承具体类？
接口可以继承接口，而且支持多重继承。

抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。

### 30、一个”.java”源文件中是否可以包含多个类(不是内部类)？

可以，但一个源文件中最多只能有一个公开类(publicclass)而且文件名必须和公开类的类名完全保持一致。

### 31、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？

可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。



### 32、内部类可以引用它的包含类(外部类)的成员吗？

一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

### 33、Java中的final关键字有哪些用法？

1. 修饰类：表示该类不能被继承；
2. 修饰方法：表示方法不能被重写；
3. 修饰变量：表示变量只能一次赋值以后值不能被修改(常量)。


### 34、比较一下Java和JavaSciprt

JavaScript与Java是两个公司开发的不同的两个产品。Java是原SunMicrosystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。

下面对两种语言间的异同作如下比较：
* **基于对象和面向对象**：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象(Object-Based)和事件驱动(Event-Driven)的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。

* **解释和编译**：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。(目前的浏览器几乎都使用了JIT(即时编译)技术来提升JavaScript的运行效率)

* **强类型变量和类型弱变量**：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。

* **代码格式不一样**

### 35、什么时候用断言(assert)？

断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。

### 36、Error和Exception有什么区别？

Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。

### 37、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？

Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。

Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出(throw)一个异常对象，可以通过它的类型来捕获(catch)它，或通过总是执行代码块(finally)来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常(当然声明异常时允许无病呻吟)；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。



### 38、运行时异常与受检异常有何异同？

异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在**EffectiveJava**中对异常的使用给出了以下指导原则：
*  不要将异常处理用于正常的控制流(设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常)
* 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
* 避免不必要的使用受检异常(可以通过一些状态检测手段来避免异常的发生)
* 优先使用标准的异常
* 每个方法抛出的异常都要有文档
* 保持异常的原子性
* 不要在catch中忽略掉捕获到的异常

### 39、列出一些你常见的运行时异常？

* ArithmeticException(算术异常)

* ClassCastException(类转换异常)

* IllegalArgumentException(非法参数异常)

* IndexOutOfBoundsException(下标越界异常)

* NullPointerException(空指针异常)

* SecurityException(安全异常)


### 40、阐述final、finally、finalize的区别。

* **final**：修饰符(关键字)有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。


* **finally**：通常放在try…catch…的后面构造总是执行代码块，这就意味着

程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。

* **finalize**：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。

### 41、List、Set、Map是否继承自Collection接口？

List、Set是，Map不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素(数学中的集合也是如此)，List是线性结构的容器，适用于按数值索引访问元素的情形。

### 42、阐述ArrayList、Vector、LinkedList的存储性能和特性。

ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。

LinkedList使用双向链表实现存储(将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高)，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

Vector属于遗留容器(Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器)，已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用(这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现)。

### 43、Java中如何实现序列化，有什么意义？

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题(如果不进行序列化可能会存在数据乱序的问题)。

要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。

### 44、Java中有几种类型的流？
字节流和字符流。

字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。

关于Java的I/O需要注意的有两点：一是两种对称性(输入和输出的对称性，字节和字符的对称性)；二是两种设计模式(适配器模式和装潢模式)。另外Java中的流不同于C#的是它只有一个维度一个方向。

### 45、XML文档定义有几种形式？

XML文档定义分为DTD和Schema两种形式

**它们之间有何本质区别？**

二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。

**解析XML文档有哪几种方式？**

对XML的解析主要有DOM(文档对象模型，DocumentObjectModel)、SAX(SimpleAPIforXML)和StAX(Java6中引入的新的解析XML的方式，StreamingAPIforXML)

### 46、你在项目中哪些地方用到了XML？

XML的主要作用有两个方面：数据交换和信息配置。

### 47、阐述JDBC操作数据库的步骤。

下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤。

1. 加载驱动
2. 创建连接
3. 创建语句
4. 执行语句
5. 处理结果
6. 关闭资源

### 48、Statement和PreparedStatement有什么区别？

与Statement相比，
1. PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性(减少SQL注射攻击的可能性)；
2. PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；
3. 当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快(不用再次编译和生成执行计划)。

### 49、什么是DAO模式？

DAO(DataAccessObject)顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交
互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。

DAO模式实际上包含了两个模式，一是DataAccessor(数据访问器)，二是DataObject(数据对象)，前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。



### 50、事务的ACID是指什么？

* 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；

* 一致性(Consistent)：事务结束后系统状态是一致的；

* 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；

* 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。


### 51、JDBC中如何进行事务处理？


Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC3.0中还引入了Savepoint(保存点)的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。


### 52、JDBC能否处理Blob和Clob？

Blob是指二进制大对象(BinaryLargeObject)，而Clob是指大字符对象(CharacterLargeObjec)，因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。

### 53、简述正则表达式及其用途。

在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

### 54、Java中是如何支持正则表达式操作的？

Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作。

### 55、如何通过反射获取和设置对象私有字段的值？

可以通过类对象的getDeclaredField()方法字段(Field)对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。


### 56、什么是UML？

UML是统一建模语言(UnifiedModelingLanguage)的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。



### 57、UML中有哪些常用的图？

UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图(usecasediagram)、类图(classdiagram)、时序图(sequencediagram)、协作图(collaborationdiagram)、状态图(statechartdiagram)、活动图(activitydiagram)、构件图(componentdiagram)、部署图(deploymentdiagram)等。在这些图形化符号中，有三种图最为重要，分别是：用例图(用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系)、类图(描述类以及类与类之间的关系，通过该图可以快速了解系统)、时序图(描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务)。

### 58、Java中能创建volatile数组吗？

能，Java中可以创建volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。

### 59、volatile能使得一个非原子操作变成原子操作吗？

一个典型的例子是在类中有一个long类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为volatile。为什么？因为Java中读取long类型变量不是原子的，需要分成两步，如果一个线程正在修改该long变量的值，另一个线程可能只能看到该值的一半(前32位)。但是对一个volatile型的long或double变量的读写是原子。

### 60、volatile修饰符的有过什么实践？

一种实践是用volatile修饰long和double变量，使其能按原子类型来读写。double和long都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个32位，然后再读剩下的32位，这个过程不是原子的，但Java中volatile型的long或double变量的读写是原子的。volatile修复符的另一个作用是提供内存屏障(memorybarrier)，例如在分布式框架中的应用。简单的说，就是当你写一个volatile变量之前，Java内存模型会插入一个写屏障(writebarrier)，读一个volatile变量之前，会插入一个读屏障(readbarrier)。意思就是说，在你写一个volatile域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

### 61、volatile类型变量提供什么保证？

volatile变量提供顺序和可见性保证，例如，JVM或者JIT为了获得更好的性能会对语句重排序，但是volatile类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。volatile提供happens-before的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile还能提供原子性，如读64位数据类型，像long和double都不是原子的，但volatile类型的double和long就是原子的。

### 52、10个线程和2个线程的同步代码，哪个更容易写？
从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。

### 63、什么是Busyspin？我们为什么要使用它？
Busyspin是一种在不释放CPU的基础上等待事件的技术。它经常用于避免丢失CPU缓存中的数据(如果线程先暂停，之后在其他CPU上运行就会丢失)。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用sleep()或wait()方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX分布式框架是一个高性能线程间通信的库，该库有一个BusySpinWaitStrategy类就是基于这个概念实现的，使用busyspin循环EventProcessors等待屏障。

### 64、Java中怎么获取一份线程dump文件？
在Linux下，你可以通过命令kill-3PID(Java进程的进程ID)来获取Java应用的dump文件。在Windows下，你可以按下Ctrl+Break来获取。这样JVM就会将线程的dump文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。

### 65、Swing是线程安全的？
不是，Swing不是线程安全的。你不能通过任何线程来更新Swing组件，如JTable、JList或JPanel，事实上，它们只能通过GUI或AWT线程来更新。这就是为什么Swing提供invokeAndWait()和invokeLater()方法来获取其他线程的GUI更新请求。这些方法将更新请求放入AWT的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。

### 66、什么是线程局部变量？
线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下(如web服务器)使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java应用就存在内存泄露的风险。



### 67、什么是不可变对象(immutable object)？

不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如String、Integer及其它包装类。


### 68、我们能创建一个包含可变对象的不可变对象吗？

是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。

### 69、Java中应该使用什么数据类型来代表价格？
如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的double类型。

### 70、怎么将byte转换为String？
可以使用String接收byte[]参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。

### 71、我们能将int强制转换为byte类型的变量吗？

是的，我们可以做强制转换，但是Java中int是32位的，而byte是8位的，所以，如果强制转化是，int类型的高24位将会被丢弃，byte类型的范围是从-128到128。

### 72、哪个类包含clone方法？是Cloneable还是Object？

java.lang.Cloneable是一个标示性接口，不包含任何方法，clone方法在object类中定义。并且需要知道clone()方法是一个本地方法，这意味着它是由c或c++或其他本地语言实现的。

### 73、Java中++操作符是线程安全的吗？

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

### 74、a=a+b与a+=b的区别

+=隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如byte、short或者int，首先会将它们提升到int类型，然后在执行加法操作。如果加法操作的结果比a的最大值要大，则a+b会出现编译错误，但是a+=b没问题

### 75、能在不进行强制转换的情况下将double值赋值给long类型的变量吗？

不行，你不能在没有强制类型转换的前提下将一个double值赋值给long类型的变量，因为double类型的范围比long类型更广，所以必须要进行强制转换。

### 76、3*0.1==0.3将会返回什么？true还是false？

false，因为有些浮点数不能完全精确的表示出来。

### 77、int和Integer哪个会占用更多的内存？

Integer对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是int是一个原始类型的数据，所以占用的空间更少。

### 78、为什么Java中的String是不可变的(Immutable)？

Java中的String不可变是因为Java的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。

### 79、我们能在Switch中使用String吗？

从Java7开始，我们可以在switchcase中使用字符串，但这仅仅是一个语法糖。内部实现在switch中使用字符串的hashcode。

### 80、Java中的构造器链是什么？

当你从一个构造器中调用另一个构造器，就是Java中的构造器链。这种情况只在重载了类的构造器的时候才会出现。

### 81、64位JVM中，int的长度是多数？
Java中，int类型变量的长度是一个固定值，与平台无关，都是32位。意思就是说，在32位和64位的Java虚拟机中，int类型的长度是相同的。

### 82、Serial与ParallelGC之间的不同之处？
Serial与Parallel在GC执行的时候都会引起stop-the-world。它们之间主要不同serial收集器是默认的复制收集器，执行GC的时候只有一个线程，而parallel收集器使用多个GC线程来执行。

### 83、32位和64位的JVM，int类型变量的长度是多数？
32位和64位的JVM中，int类型变量的长度是相同的，都是32位或者4个字节。

### 84、Java中WeakReference与SoftReference的区别？
虽然WeakReference与SoftReference都有利于提高GC和内存的效率，但是WeakReference，一旦失去最后一个强引用，就会被GC回收，而软引用虽然不能阻止被回收，但是可以延迟到JVM内存不足的时候。

### 85、WeakHashMap是怎么工作的？
WeakHashMap的工作与正常的HashMap类似，但是使用弱引用作为key，意思就是当key对象没有任何引用时，key/value将会被回收。

### 86、JVM选项-XX:+UseCompressedOops有什么作用？

当你将你的应用从32位的JVM迁移到64位的JVM时，由于对象的指针从32位增加到了64位，因此堆内存会突然增加，差不多要翻倍。这也会对CPU缓存(容量比内存小很多)的数据产生不利的影响。因为，迁移到64位的JVM主要动机在于可以指定最大堆大小，通过压缩OOP可以节省一定的内存。通过-XX:+UseCompressedOops选项，JVM会使用32位的OOP，而不是64位的OOP。

### 87、怎样通过Java程序来判断JVM是32位还是64位？

你可以检查某些系统属性如sun.arch.data.model或os.arch来获取该信息。

### 88、32位JVM和64位JVM的最大堆内存分别是多数？
理论上说上32位的JVM堆内存可以到达2^32，即4GB，但实际上会比这个小很多。不同操作系统之间不同，如Windows系统大约1.5GB，Solaris大约3GB。64位JVM允许指定最大的堆内存，理论上可以达到2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到100GB。甚至有的JVM，如Azul，堆内存到1000G都是可能的。

### 89、JRE、JDK、JVM及JIT之间有什么不同？
JRE代表Java运行时(Javarun-time)，是运行Java引用所必须的。JDK代表Java开发工具(Javadevelopmentkit)，是Java程序的开发工具，如Java编译器，它也包含JRE。JVM代表Java虚拟机(Javavirtualmachine)，它的责任是运行Java应用。JIT代表即时编译(JustInTimecompilation)，当代码执行的次数超过一定的阈值时，会将Java字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高Java应用的性能。

### 90、解释下Java堆空间及GC？
当通过Java命令启动Java进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC是JVM内部的一个进程，回收无效对象的内存用于将来的分配。

### 91、你能保证GC执行吗？
不能，虽然你可以调用System.gc()或者Runtime.gc()，但是没有办法保证GC的执行。


### 92、怎么获取Java程序使用的内存？堆使用的百分比？

可以通过java.lang.Runtime类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory()方法返回剩余空间的字节数，Runtime.totalMemory()方法总内存的字节数，Runtime.maxMemory()返回最大内存的字节数。

### 93、Java中堆和栈有什么区别？
JVM中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个JVM的所有线程共享。

### 94、“a==b”和”a.equals(b)”有什么区别？
如果a和b都是对象，则a==b是比较两个对象的引用，只有当a和b指向的是堆中的同一个对象才会返回true，而a.equals(b)是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String类重写equals()方法，所以可以用于两个不同对象，但是包含的字母相同的比较。

### 95、a.hashCode()有什么用？与a.equals(b)有什么关系？
hashCode()方法是相应对象整型的hash值。它常用于基于hash的集合类，如Hashtable、HashMap、LinkedHashMap等等。它与equals()方法关系特别紧密。根据Java规范，两个使用equal()方法来判断相等的对象，必须具有相同的hashcode。

### 96、final、finalize和finally的不同之处？
final是一个修饰符，可以修饰变量、方法和类。如果final修饰变量，意味着该变量的值在初始化后不能被改变。finalize方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用finalize没有保证。finally是一个关键字，与try和catch一起用于异常的处理。finally块一定会被执行，无论在try块中是否有发生异常。

### 97、Java中的编译期常量是什么？使用它又什么风险？
公共静态不可变(publicstaticfinal)变量也就是我们所说的编译期常量，这里的public可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖JAR文件时，确保重新编译你的程序。

### 98、用哪两种方式来实现集合的排序？

你可以使用有序集合，如TreeSet或TreeMap，你也可以使用有顺序的的集合，如list，然后通过Collections.sort()来排序。

### 99、Java中怎么打印数组？

你可以使用Arrays.toString()和Arrays.deepToString()方法来打印数组。由于数组没有实现toString()方法，所以如果将数组传递给System.out.println()方法，将无法打印出数组的内容，但是Arrays.toString()可以打印每个元素。

### 100、Java中的LinkedList是单向链表还是双向链表？

是双向链表，你可以检查JDK的源码。在Eclipse，你可以使用快捷键Ctrl+T，直接在编辑器中打开该类。

### 101、Hashtable与HashMap有什么不同之处？
这两个类有许多不同的地方，下面列出了一部分：

a)Hashtable是JDK1遗留下来的类，而HashMap是后来增加的。b)Hashtable是同步的，比较慢，但HashMap没有同步策略，所以会更快。c)Hashtable不允许有个空的key，但是HashMap允许出现一个nullkey。更多的不同之处参见答案。


### 102、Java中的HashSet，内部是如何工作的？
HashSet的内部采用HashMap来实现。由于Map需要key和value，所以所有key的都有一个默认value。类似于HashMap，HashSet不允许重复的key，只允许有一个nullkey，意思就是HashSet中只允许存储一个null对象。


### 103、我们能自己写一个容器类，然后使用for-each循环码？
可以，你可以写一个自己的容器类。如果你想使用Java中增强的循环来遍历，你只需要实现Iterable接口。如果你实现Collection接口，默认就具有该属性。

### 104、Java中，编写多线程程序的时候你会遵循哪些最佳实践？
这是我在写Java并发程序的时候遵循的一些最佳实践：

1. 给线程命名，这样可以帮助调试。
2. 最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。
3. 如果可以，更偏向于使用volatile而不是synchronized。
4. 使用更高层次的并发工具，而不是使用wait()和notify()来实现线程间通信，如BlockingQueue，CountDownLatch及Semeaphore。
5. 优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。


### 105、说出几点Java中使用Collections的最佳实践
这是我在使用Java中Collectionc类的一些最佳实践：

1. 使用正确的集合类，例如，如果不需要同步列表，使用ArrayList而不是Vector。
2. 优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。
3. 使用接口代表和访问集合，如使用List存储ArrayList，使用Map存储HashMap等等。
4. 使用迭代器来循环集合。e)使用集合的时候使用泛型。


### 106、说出几条Java中方法重载的最佳实践？
下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。

1. 不要重载这样的方法：一个方法接收int参数，而另个方法接收Integer参数。
2. 不要重载参数数量一致，而只是参数顺序不同的方法。
3. 如果重载的方法参数个数多于5个，采用可变参数。

### 107、在多线程环境下，SimpleDateFormat是线程安全的吗？
不是，非常不幸，DateFormat的所有实现，包括SimpleDateFormat都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如将SimpleDateFormat限制在ThreadLocal中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐joda-time库。

### 108、接口是什么？为什么要使用接口而不是直接使用具体类？
接口用于定义API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如List接口，你可以使用可随机访问的ArrayList，也可以使用方便插入和删除的LinkedList。接口中不允许写代码，以此来保证抽象，但是Java8中你可以在接口声明静态的默认方法，这种方法是具体的。

### 109、Java中，抽象类与接口之间有什么不同？
Java中，抽象类和接口有很多不同之处，但是最重要的一个是Java中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。


### 110、抽象类是什么？它与接口有什么区别？你为什么要使用抽象类？

接口用于规范，抽象类用于共性.

声明方法的存在而不去实现它的类被叫做抽象类

接口(interface)是抽象类的变体。在接口中，所有方法都是抽象的。

### 111、构造器注入和setter依赖注入，那种方式更好？

每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是setter注入提供更好的灵活性来设置可选依赖。如果使用XML来描述依赖，Setter注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用setter注入。

### 112、依赖注入和工程模式之间有什么不同？
虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用DI会比使用工厂模式更容易测试。


### 113、适配器模式和装饰器模式有什么区别？
虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。

### 114、适配器模式和代理模式之前有什么不同？
这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。

### 115、什么是模板方法模式？
模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用Comparable或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。

### 116、什么时候使用访问者模式？
访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。

### 117、什么时候使用组合模式？

组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。

### 118、继承和组合之间有什么不同？
虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。

### 119、描述Java中的重载和重写？
重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。

### 120、Java中，嵌套公共静态类与顶级类有什么不同？
类的内部可以有多个嵌套公共静态类，但是一个Java源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。

### 121、OOP中的组合、聚合和关联有什么区别？
如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象A是由对象B
组合的，则A不存在的话，B一定不存在，但是如果A对象聚合了一个对象B，则即使A不存在了，B也可以单独存在。

### 122、给我一个符合开闭原则的设计模式的例子？
开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是Collections.sort()方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改sort()方法，你需要做的仅仅是实现你自己的Comparator接口。

### 123、抽象工厂模式和原型模式之间的区别？

抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。

原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，原型模式中的工厂方法为clone，它会返回一个拷贝(可以是浅拷贝，也可以是深拷贝，由设计者决定)。为了保证用户代码中到时可以通过指针调用clone来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。### 什么时候使用享元模式？
享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK中String池、Integer池以及Long池都是很好的使用了享元模式的例子。

### 124、嵌套静态类与顶级类有什么区别？
一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如HashMap.Entry是一个嵌套静态类，HashMap是一个顶级类，Entry是一个嵌套静态类。

### 125、Java中，受检查异常和不受检查异常的区别？
受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过throws子句声明。其中一种情况是Exception的子类但不是RuntimeException的子类。非受检查是RuntimeException的子类，在编译阶段不受编译器的检查。

### 126、Java中，Serializable与Externalizable的区别？
Serializable接口是一个序列化Java类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是JVM内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。


### 127、Java中，DOM和SAX解析器有什么不同？
DOM解析器将整个XML文档加载到内存来创建一棵DOM模型树，这样可以更快的查找节点和修改XML结构，而SAX解析器是一个基于事件的解析器，不会将整个XML文档加载到内存。由于这个原因，DOM比SAX更快，也要求更多的内存，不适合于解析大XML文件。

### 128、说出JDK1.7中的三个新特性？
虽然JDK1.7不像JDK5和8一样的大版本，但是，还是有很多新的特性，如try-with-resource语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java会自动关闭。Fork-Join池某种程度上实现Java版的Map-reduce。允许Switch中有String变量和文本。菱形操作符(<>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个catch块中捕获多个异常。


### 129、说下JDK1.8引入的新特性？
Lambda表达式，允许像对象一样传递匿名函数

StreamAPI，充分利用现代多核CPU，可以写出很简洁的代码

Date与TimeAPI，最终，有一个稳定、简单的日期和时间库可供你使用扩展方法，现在，接口中可以有静态、默认方法。

重复注解，现在你可以将相同的注解在同一类型上使用多次。

 