今天和大家聊一下最最最基础的吧，虽然简单，但坑无处不在，会则巩固，不会牢记，面试不能惨死于这些最基础的知识点上~

---

### 老面👴：什么是基础类型与引用类型？有什么区别？

笑小枫🍁：基础类型只表示简单的字符或数字，引用类型可以是任何复杂的数据结构。

区别：
1. 存储方式不同，基本类型是存储在栈内存；引用类型变量是存放在堆内存中，栈中存放的是变量存放的内存地址。
2. 传递方式不同，基本变量类型是值传递；引用变量类型是引用传递。

---

### 老面👴：String是基础的数据类型吗？ 

笑小枫🍁：不是，是引用类型。String数据存储是`private final char value[];`所以String类是不可变的，对String类的任何改变，都是返回一个新的String类对象。 

---

### 老面👴：JAVA有几种基础数据类型？对应的包装类是什么？

笑小枫🍁：**八种**

基本数据类型：int，double，long，float，short，byte，char，boolean

对应的封装类型是：Integer，Double，Long，Float，Short，Byte，Character，Boolean

---

### 老面👴：什么是自动装箱与拆箱？

笑小枫🍁：

**装箱**：将基本类型用它们对应的引用类型包装起来；

**拆箱**：将包装类型转换为基本数据类型。

---

### 老面👴：int和Integer哪个会占用更多的内存？

笑小枫🍁：Integer对象会占用更多的内存。Integer是一个对象，需要存储对象的信息。但是int是一个原始类型的数据，所以占用的空间更少。

32 位机器下，Integer占用的内存情况如下：

![img](https://image.xiaoxiaofeng.site/article/img/2023/03/06/xxf-20230306093800.png)

---

### 老面👴：i64位JVM中，int的长度是多少位？

笑小枫🍁：Java中，int类型变量的长度是一个固定值，与平台无关，都是32位。意思就是说，在32位和64位的Java虚拟机中，int类型的长度是相同的。

---

### 老面👴：i怎么将byte转换为String？

笑小枫🍁：可以使用String接收byte[]参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。

![image-20230306105100095](https://image.xiaoxiaofeng.site/article/img/2023/03/06/xxf-20230306105102.png)

---

### 老面👴：i我们能将int强制转换为byte类型的变量吗？

笑小枫🍁：是的，我们可以做强制转换，但是Java中int是32位的，而byte是8位的，所以，如果强制转化时，int类型的高24位将会被丢弃，byte类型的范围是从-128到127。

![image-20230306110501695](https://image.xiaoxiaofeng.site/article/img/2023/03/06/xxf-20230306110503.png)

---

### 老面👴：ibyte类型127+1等于多少?

笑小枫🍁：如果结果是byte类型，答案是：-128。

![image-20230306101108268](https://image.xiaoxiaofeng.site/article/img/2023/03/06/xxf-20230306101110.png)

如果结果转为int类型，答案是：128。

![image-20230306101347326](https://image.xiaoxiaofeng.site/article/img/2023/03/06/xxf-20230306101349.png)

解析：

byte的范围是-128~127。

字节长度为8位，最左边的是符号位，而127的二进制为01111111，所以执行+1操作时，01111111变为10000000。

大家知道，计算机中存储负数，存的是补码的兴衰。左边第一位为符号位。

那么负数的补码转换成十进制如下：

一个数如果为正，则它的原码、反码、补码相同；一个正数的补码，将其转化为十进制，可以直接转换。

已知一个负数的补码，将其转换为十进制数，步骤如下：

1.  先对各位取反；
2.  将其转换为十进制数；
3.  加上负号，再减去1；

例如10000000，最高位是1，是负数，对各位取反得01111111，转换为十进制就是127，加上负号得-127，再减去1得-128；

---

### 老面👴：ifloat 和 double 的区别是什么？

笑小枫🍁：

1. **内存中占有的字节数不同**

单精度浮点数在内存中占有4个字节；

双精度浮点数在内存中占有8个字节；

2. **有效数字位数不同**

单精度浮点数有效数字8位；

双精度浮点数有效数字16位；

3. **数值取值范围不同**

单精度浮点数的表示范围：-3.40E+38~3.40E+38

双精度浮点数的表示范围：-1.79E+308~-1.79E+308

4. **在程序中处理速度不同**

一般来说，CPU处理单精度浮点数的速度比双精度浮点数的速度快

如果不声明，默认小数是double类型，如果想用float，要进行强转；

---

### 老面👴：i能在不进行强制转换的情况下将double值赋值给long类型的变量吗？

笑小枫🍁：不行，不能在没有强制类型转换的前提下将一个double值赋值给long类型的变量，因为double类型的范围比long类型更广，所以必须要进行强制转换。

---

### 老面👴：i3*0.1==0.3将会返回什么？

笑小枫🍁：返回false，因为浮点数不能完全精确的表示出来，一般会损失精度。

![image-20230306102640075](https://image.xiaoxiaofeng.site/article/img/2023/03/06/xxf-20230306102642.png)

---

### 老面👴：ifloat f = 3.4;是否正确？

笑小枫🍁：不正确。3.4是双精度数，将双精度型(double)赋值给浮点型(float)属于下转型(down-casting，也称为窄化)会造成精度损失，因此需要强制类型转换`floatf=(float)3.4`;或者写成`floatf=3.4F;`。

---

### 老面👴：ishort s1 = 1; s1 = s1+1;有错吗?short s1=1; s1+=1;有错吗？

笑小枫🍁：对于`short s1=1;` `s1=s1+1;`由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型；所以编译会报错。

而`short s1=1;` `s1+=1;`可以正确编译，因为`s1+=1;`相当于`s1=(short)(s1+1);`其中有隐含的强制类型转换。

![image-20230306105518346](https://image.xiaoxiaofeng.site/article/img/2023/03/06/xxf-20230306105520.png)

---

### 老面👴：你们项目中金额是使用的什么类型？

笑小枫🍁：Java代码中使用java.math.BigDecimal；Mysql数据库中使用decimal 。

因为float、double都是浮点数, 都有取值范围, 都有精度范围. 浮点数与通常使用的小数不同, 使用中, 往往难以确定。所以说，float和double都是不能用来表示精确的类型的；金额必须是完全精确的计算, 故不能使用double或者float, 而应该采java.math.BigDecimal。

---

### 老面👴：简单说说BigDecimal的加减乘除操作吧

笑小枫🍁：

* 加法运算：add()
* 减法运算：subtract()
* 乘法运算：multiply()
* 除法运算：divide()


---

### 老面👴：BigDecimal两个数据之间怎么比较？

Java中对BigDecimal比较大小一般用的是Bigdemical的compareTo方法

比较的结果 
-1，表示小于 
0，表示等于 
1，大于 
